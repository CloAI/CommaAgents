from typing import Optional, TypedDict

class PromptTemplate():
    class PromptParameters(TypedDict, total=True):
        system_message: str

    def __init__(
            self,
            format: str = "{system_message}\n{user_message}\n{assistant_message}",
            parameters: "PromptTemplate.PromptParameters" = {
                "system_message": ""
            },
            remember_context: bool = False,
            context_window_size: Optional[int] = None,
    ):
        self.prompt_format = format
        self.remember_context = remember_context
        self.context_window_size = context_window_size
        self.parameters = parameters
        self.historical_context = []

    def append_history(self, message: str, assistant_response: str):
        self._update_historical_context(message, assistant_response)

    def _update_historical_context(self, message: str, assistant_response: str) -> None:
        """
        Appends the given prompt and response pair to the agent's historical context.

        This method is used to maintain a record of the interactions (prompts and responses) between the agent 
        and the Agent. It appends the prompt and response as a tuple to the historical context list. If a context 
        window size is set, this method also ensures that the history is trimmed to maintain only the most recent 
        interactions as specified by the window size.

        Parameters
        ----------
        prompt : str
            The prompt that was sent to the Agent.
        response : str
            The response generated by the Agent.

        Notes
        -----
        - The historical context is used to maintain a continuity in conversations, which can be crucial for 
        applications requiring context-aware responses.
        - If the `context_window_size` is set, this method will ensure that the number of stored interactions 
        does not exceed this limit, removing the oldest entries as needed.

        Examples
        --------
        >>> agent = BaseAgent(name="ExampleAgent", remember_context=True, context_window_size=3)
        >>> agent._update_historical_context("How's the weather?", "It's sunny.")
        >>> agent._update_historical_context("What about tomorrow?", "Partly cloudy.")
        >>> print(agent.historical_context)
        [("How's the weather?", "It's sunny."), ("What about tomorrow?", "Partly cloudy.")]
        """
        self.historical_context.append({
            "user_message": message,
            "assistant_message": assistant_response
        })

        # Check if history context window size is set and enforce the limit
        if self.context_window_size is not None:
            while len(self.historical_context) > self.context_window_size:
                self.historical_context.pop(0)  # Remove the oldest entry

    def build_prompt_str(self, message: str):
        prompt = ""
        if self.remember_context:
            for context in self.historical_context:
                historical_parameters = self.parameters.copy()
                historical_parameters["user_message"] = context["user_message"]
                historical_parameters["assistant_message"] = context["assistant_message"]
                prompt += self.prompt_format.format(**historical_parameters)
                
        prompt += self.prompt_format.format(user_message=message, assistant_message="", **self.parameters)
        return prompt
        
    
    def summary(self):
        return str({
            "prompt_format": self.prompt_format,
            "remember_context": self.remember_context,
            "context_window_size": self.context_window_size,
            "parameters": self.parameters,
            "historical_context": self.historical_context
        })